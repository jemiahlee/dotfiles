#!/usr/bin/env perl

use warnings;
use strict;
use Cwd qw/cwd/;
use File::Find;
use Getopt::Long;

my $START_DIR = cwd();
my($verbose, $dry_run);

GetOptions(
  'dry_run|n' => \$dry_run,
  'verbose'   => \$verbose,
);

my $DROPBOX_BASE_DIR = qq{$ENV{HOME}/Dropbox/Music};
my $AUDIO_FILE_BASE_DIR = qq{$ENV{HOME}/Music/Phile Audio/audio};

find(\&wanted, $AUDIO_FILE_BASE_DIR);
chdir $START_DIR;

sub wanted {
    return unless /(?:mp3|flac)$/;
    return unless $File::Find::dir =~ m{.*/([^/]+)/([^/]+)/Disc (\d+)};

    chdir $File::Find::dir;

    my($artist, $album, $disc_number) = ($1, $2, $3);
    print "$File::Find::name : $artist || $album || $disc_number\n";

    my $fixed_filename = fix_filename($_, $File::Find::name, $disc_number);
    print "Filename is now $fixed_filename\n";
    exit;
}

sub fix_filename {
    my($short_filename, $filename, $disc_number) = @_;

    my $is_part_of_multi_disc = $disc_number > 1 || check_for_multiple_discs($filename);
    print '     ', ($is_part_of_multi_disc ? 'is ' : 'is not '), "part of a multi-disc collection\n";

    my $new_filename = $short_filename;
    if($is_part_of_multi_disc) {
        $new_filename =~ s{^}{/Disc_$disc_number-};
        print "Would rename $short_filename to $new_filename\n";
    }

    my $cwd = cwd();
    print qq{Running `mp3capitalize --bare-print --dry-run '$new_filename'` in $cwd\n};
    `mp3capitalize --bare-print --dry-run '$new_filename'`;
}

sub check_for_multiple_discs {
    my $filename = shift;

    my @file_parts = split m{/Disc}, $filename;
    opendir CURRENT_DIR, $file_parts[0] or die "Couldn't open directory $file_parts[0]: $!";
    my @files = readdir CURRENT_DIR;
    closedir CURRENT_DIR;

    return scalar(grep /Disc/, @files) > 1;
}

__DATA__


unless($dry_run) {
  `mp3capitalize *.flac`;
  `mp3capitalize *.mp3`;
}

my @filenames_to_process = get_appropriate_filenames();

foreach my $type (qw/mp3 flac/) {
  my @files = grep /$type/, @filenames_to_process;
  unless(@files) {
    print "No files of type $type, skipping!\n" if $verbose or $dry_run;
    next;
  }

  print "Found filenames: @files (type $type)\n" if $verbose or $dry_run;

  my $to_dir = join(q{/}, $DROPBOX_BASE_DIR, $type, $dirname);
  find_and_delete_files_with_same_prefix($to_dir, @files);

  print "Ensuring destination directory $to_dir exists...\n" if $verbose or $dry_run;
  `mkdir -p $to_dir` unless $dry_run;

  foreach my $file (sort @files) {
    unless($dry_run) {
      print "Moving $file to $to_dir/$file\n";
      rename $file, "$to_dir/$file";
    }
  }
}

sub get_appropriate_filenames {
  opendir CURRENT_DIR, '.' or die "Couldn't open current directory: $!";
  my @files = readdir CURRENT_DIR;
  closedir CURRENT_DIR;

  return grep /\.(?:mp3|flac)$/, @files;
}

sub find_and_delete_files_with_same_prefix {
  my $to_dir = shift;

  return unless -d $to_dir;

  if(grep /^\d/, @_) {
    print "Would delete $to_dir/* since there are numbers at the starts of the filenames\n" if $dry_run;
    print "Deleting $to_dir/* since there are numbers at the starts of the filenames\n" unless $dry_run;
    `rm -f $to_dir/*` unless $dry_run;
  }

  if(grep /^Disc_/, @_) {
    my %prefixes;
    foreach my $filename (@_) {
      next unless $filename =~ /^(Disc_\d+)/;
      $prefixes{$1} = 1;
    }

    foreach my $prefix (keys %prefixes) {
      print "Would delete $to_dir/$prefix* since there are discs at the starts of the filenames\n" if $dry_run;
      print "Deleting $to_dir/$prefix* since there are discs at the starts of the filenames\n" unless $dry_run;
      `rm -f $to_dir/$prefix*` unless $dry_run;
    }
  }
}
